		// Installed git and committed this file 
         // 
         //    ptest

         //  temp driver program to test
         //  pwrap.sub.
         // 
         // 

.pc = $1000
		 
jmp ptest // skip over data area


.label strp = $fb				//  String Pointer
.label scnp = $fd 				//  Screen Pointer (video RAM)
.label curlin = $a5			//  current line number
.label curcol = $a6			//  current column number
.label curlen = $a7			//  length of current non-space string segment
.label savy = $a8				//  temporary storage for 'Y' register

.label vmcsb    = $d018       // VIC-II memory
                       // control reg.
.label plot     = $e50a       // Kernal routine
         // to position the cursor
wf       !byte 0  // wrap flag for print.
         // 
         // if wf is set, print with
         // word wrapping. If flag is
         // clear, print w/o wrapping

dogetl   !byte 0  // flag - do getlength

!convtab pet {	//  Convert text strings into PETSCII.
					//  Using our own "conv" routine to convert
					//  PETSCII to screencodes, instead of ACME's !scr,
					//  so that we can also handle control characters 
					//  such as <RETURN> (#$0d)
					
string1 !text "This is another test. I will put in several different strings "
        !text "to check the operation of the wrap subroutine. This line"
        !text " does not have leading spaces in it. Line ends here.  "
		 !text "Another line follows: ", 13 //  Return char
		 !text "This line ends with a zero delimiter. Bye now!",0
}

ptest
         // put random values in A, x,
         // and y, to test that they are
         // properly restored at end of
         // subroutine.
         // delete this section after
         // testing is completed.

         lda #$33
         ldx #$dd
         ldy #$ff

         // point strp to start address
         // of our test string:

         jsr bt // builld table of screen
                // addresses for col 0
         // NOTE: bt.sub uses strp!

         lda vmcsb // vic-II control reg
         ora #2
         sta vmcsb // select uppercase/
                   // lowercase charset

         lda #<string1
         sta strp
         lda #>string1
         sta strp+1

         // initialize scnp pointer and
         // curlin & curcol

         lda #$00
         sta curlin
         sta curcol
         sta scnp

         lda #$04
         sta scnp+1

         lda #$ff
         sta dogetl // set flag for
             // getlen so it will be
             // called on next non-space

         lda #$00
         sta wf

         jsr pwrap // test printing strings not wrapped

         lda #$01
         sta wf

         inc curlin // so that we have a
         //  blank line between previous
         //  text and new.

         jsr pwrap // test printing strings wrapped

         rts // return to calling prg


// ==================================================
// 
//   Subroutine to be tested...
// 
// ==================================================

         //  Subroutine "pwrap.sub"
         // 
         // 
         //  prints a string to screen
         //  using
         // 
         //  strp = string pointer
         //  scnp = screen pointer
         // 
         //  advances scnp to column zero
         //  of next line (updates
         //  variables curlin & curcol)
         // 
         //  also wraps a word to the
         //  next line if it would run
         //  past column 39
         // 





pwrap    // save registers on stack

         pha
         txa
         pha
         tya
         pha

         lda #0
         sta curcol // start on column 0

         // clear screen
         // jsr cls


         // get screen address for
         // column zero of current row
         // and set our variables

         jsr setline // (uses curlin)


                     // sets (scnp) to
         // column zero of line number
         // in curlin


			ldy #$ff// index into string


loop1    	iny // main loop

noiny    	lda (strp),y // char in string
			beq jmpout // delimiter reached.
			cmp #$20 // space char?
			beq isspc
			cmp #$0d //  Return char?
			beq isreturn //  it's a return//  print a newline 
			bne chkwf
			
isreturn
			jsr newline 
			jmp loop1

isspc
			jsr conv // convert to screencode
			jsr prin // print the spc char
			clc
			bcc loop1

         // check wrap flag. Print string
         // wrapped if flag is set.
         // Print string without wrap if
         // flag is clear.

chkwf
         lda wf
         bne pwrapped // print wrapped


         //  wf is clear//  print entire
         //  string without word wrap.
         
pnwloop
			lda (strp),y 	// get char in string
			beq pnwdone 	// delimiter reached
			cmp #$0d 		//  Return char?
			bne pnwc
			jsr newline 	//  was a Return- print newline
							//  and loop back	
			iny 			// point to next char
			jmp pnwloop
			
pnwc	 	jsr conv		// convert to screencode
           sty savy		//  save strp's y index
		    ldy curcol    //  index for printing current line
			jsr prin		// print char- which also increments curcol.
			ldy savy      //  get strp's y index back
			iny
			jmp pnwloop 	// print more


pnwdone
         // number of characters printed
         // divided by 40 = current line
         // number.

calcline
         ldx #$ff
         tya // get index y into a
calclp
         inx
         sec
         sbc #40
         bcs calclp // when carry is
         // clear, we have the current
         // line number in x

			stx curlin // calculated line #

jmpout		jmp out1// done printing-
                  // exit and return



pwrapped
         jsr getlen // get length of non-
                    // space portion of
                    // current string
                    // (in curlen)

chkrm
         lda curlen // 
         clc
         adc curcol //  if curlen + curcol
         //  is > $28, we have to wrap the
         // string segment to next line.

         clc
         cmp #$28

         bcs yeswrap // carry will be set
         // if Acc => #$28

         bcc nowrap //  carry is clear,
         // so we have room on current
         // line to print strp segment.


yeswrap  // string segment would run past
         // end of line. Print it on a
         // new line.

         jsr newline//  move cursor to
                    //  the next line, on
                    //  column zero

nowrap   ldx curlen //  index for loop

prinlp
         // getlen did not upddate 'y'
         // it's still pointing to the
         // first non-space char in
         // current string segment.

			lda (strp),y
			sty savy // save y reg
			ldy curcol // (scnp) 'y' index
			jsr conv // convert to screencode
			jsr prin		//  print char in A 
			ldy savy // get (strp) 'y' back.
			iny //  point to next char in string
			dex
			bne prinlp // loop until done.
			dey // we have to dey, because
             // beginning of loop1 does
             // iny.
			lda #0
			sta curlen//  reset curlen to zero

			jmp loop1 // get more chars


prin
			sta (scnp),y		//  assumes char in 'a' is screencode
			inc curcol			// update column #
			lda curcol			// if we're at column 40, print a newline
			cmp #$28
			bne prinrts
			jsr newline		// move cursor to next line, column zero
						
prinrts		rts // return to caller



out1
			jsr newline
			
			// use Kernal routine "PLOT" to set cursor position to one
			// line past the printed string, before returning to BASIC.
			
			ldy #0 // curlin // column #
			
			inc curlin //  one row down
			ldx curlin // row position
			clc
			jsr plot
			
			//  restore registers A, x and y
			pla
			tay
			pla
			tax
			pla
			
			rts // return to caller
			
			// 
			//  end Subroutine "pwrap.sub"
			// 
			// 
			//  (end temp driver program
			//     "ptest.a"
			// 
			// 
			



getlen		// Subroutine to get the length
			// of the current non-space part
			// of the string.
		
			// uses local variable curlen to
			// store length.
			// initialize at 1, since we
			// already have a non-space char
			// starting the current string.
		
			lda #1
			sta curlen
		
			// save y reg, since we'll use
			// it to parse string..
		
			tya
			pha
		
getlp		
			iny // get next char in string
			lda (strp),y
			beq gotlen // we reached the
						// delimiter. Exit
						// with the length.
		
			cmp #$20 // space char?
			beq gotlen // done here.
		
			inc curlen // another non-space
						// char. Increment
			clc        // curlen and
			bcc getlp  // continue getting
						// chars until a
						// space char or the
						// delimiter is
						// reached.
		
gotlen		       // we have the length
		
					// restore 'y' and
					// return
			pla
			tay
			rts //  return to caller
		
		
			// 
			// 
			// included sources follow:
		
			!src "newline.sub"
			!src "bt.sub"
			!src "cls.sub"
			!src "conv.sub"
			// 
			// 
			//  end
		
