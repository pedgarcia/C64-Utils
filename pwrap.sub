
// ==================================================
// 
//   Subroutine "pwrap.sub"
// 
// ==================================================

         	// 
         	// Prints a string to screen
         	// using direct writing to video memory.
         	//
         	// Zero-page pointers 'strp' (string pointer) and 'scnp' 
         	// (screen pointer) are defined in calling program.
         	//
         	// For newline, routine advances 'scnp' to point to column zero
         	// of next line (also updates variables curlin & curcol)
         	//
         	// also (optionally) wraps a word to the next line 
         	// if it would run past the last column on the line.
         	// (determined by flag 'wf' set in calling program)
         	//
         	// NOTE:  this and other string-handling subroutines in this
         	// collection are currently limited to processing strings of
         	// length < 256. 
         	// 
         	// Future Mods and Projects:
         	// 
         	// ** add ability to handle strings longer than 256 bytes. 
         	//
         	// ** add ability to handle control characters such as <CR>. This will 
         	//    assume that we're not using screen codes as the input strings. 
         	// 

pwrap:   	// save registers on stack

         	pha
         	txa
         	pha
         	tya
         	pha

         	lda #0
         	sta curcol		// start on column 0

         	// get screen address for column zero of current row
         	// and initialize variables

         	jsr setline 	// uses curlin)

			// sets (scnp) to column zero of line number in curlin
			// also sets 'y' register to zero

// =================================  MAIN LOOP ============================			


loop1:   	lda (strp),y 	// Point to current char in string
			beq out1 		// delimiter reached. Jump out.
prin:						// print current character, checking for end-of-line
			sta (scnp),y	// assumes char in 'A' is screencode
			cpy #$28		// column number = 40?
			beq wftest		// yes- test flag wf for printing style
			iny				// prep to point strp to next char in string
			bne loop1		// branch back and get next char (branch always)	


wftest:						// test flag 'wf' for wrap or no wrap printing
			lda wf 			// wf = wrap flag for printing wrap or no-wrap
			beq nowrap		// print without word wrap

wrap:						// print with word wrap
			jsr back_spc	// find previous space char and point strp to it.
			tya
			pha				// save 'y' register, and 
			lda #$20		// fill the rest of the line with spaces
fillspc:	
			sta (scnp),y 	// store a space char at current screen location
			iny
			cpy #$28		// are we at end of the line yet?
			bne fillspc		// no; keep going
			pla
			tay 			// restore 'y' so it points to next char in string			
			iny 			// print newline and zero 'y' register
nowrap:
			jsr newline		// move cursor to next line, column zero
							// newline also increments curlin and updates strp, 
							// and resets 'y' to zero
			jmp loop1		// jump back to loop and print more


out1:
			jsr newline		// add a blank line after the text block
			
			// use Kernal routine "PLOT" to set cursor position to one
			// line past the printed string, before returning to caller.
			
			ldy #0			// curlin column number for PLOT routine
			
			inc curlin 		// one row down
			ldx curlin 		// row position
			clc 			// clc to write cursor position
			jsr plot 		// call Kernal subroutine to position cursor
			
			//  restore registers A, x and y from stack
			pla
			tay
			pla
			tax
			pla
			
			rts 			// return to caller
			
			// 
			//  end Subroutine "pwrap.sub"
			// 
			// 
			// required subroutine sources follow:
		
			.import source "newline.sub"	// prints a newline
			.import source "bt.sub"			// builds table of column zero addresses
			.import source "cls.sub"		// clear screen
			.import source "back_spc.sub"	// back-track in string to get previous space char

			// .import source "getlen.sub"		// get length of current non-space string segment

			// 
			//  ---- End of subroutine 'pwrap'
		
