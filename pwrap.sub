
// ==================================================
// 
//   Subroutine "pwrap.sub"
// 
// ==================================================

         	// 
         	// Prints a string to screen
         	// using direct writing to video memory.
         	//
         	// Zero-page pointers 'strp' (string pointer) and 'scnp' 
         	// (screen pointer) are defined in calling program.
         	//
         	// For newline, routine advances 'scnp' to point to column zero
         	// of next line (also updates variables curlin & curcol)
         	//
         	// also (optionally) wraps a word to the next line 
         	// if it would run past the last column on the line.
         	// (determined by flag 'wf' set in calling program)
         	//
         	// NOTE:  this and other string-handling subroutines in this
         	// collection are currently limited to processing strings of
         	// length < 256. 
         	// 
         	// Future Mods and Projects:
         	// 
         	// ** re-write so that 'y' index register is synchronized 
         	//    for strp and scrp pointers. For each new line, strp and scrp
         	//    should both be referenced to column zero (y=0), in effect
         	//    adding 40 to both screen and string pointers in ZP.
			//    Y index for each line should therefore 
         	//    be limited to range 0-39 (screen and string pointers)
         	//
         	// ** add ability to handle strings longer than 256 bytes. 
         	//
         	// ** add ability to handle control characters such as <CR>. This will 
         	//    assume that we're not using screen codes as the input strings. 
         	// 

pwrap:   	// save registers on stack

         	pha
         	txa
         	pha
         	tya
         	pha

         	lda #0
         	sta curcol		// start on column 0

         	// get screen address for column zero of current row
         	// and initialize variables

         	jsr setline 	// uses curlin)

			// sets (scnp) to column zero of line number in curlin
			// also sets 'y' register to zero

// =================================  MAIN LOOP ============================			

loop1:   	lda (strp),y 	// Point to char in string
			beq out1 		// delimiter reached. Jump out.
			jsr prin		// print char- which also increments curcol.
			iny
			bne loop1		// branch back and get next char (branch always)	


							// print current character, checking for end-of-line
prin:
			sta (scnp),y	// assumes char in 'A' is screencode
			cpy #$28		// column number = 40?
			bne prinrts		// no- print string segment w/o newline
			jsr newline		// move cursor to next line, column zero
							// newline also increments curlin and updates strp, 
							// and resets 'y' to zero
						
prinrts:	rts 			// return to caller


out1:
			jsr newline		// add a blank line after the text block
			
			// use Kernal routine "PLOT" to set cursor position to one
			// line past the printed string, before returning to BASIC.
			
			ldy #0			// curlin column number for PLOT routine
			
			inc curlin 		//  one row down
			ldx curlin 		// row position
			clc 			// clc to write cursor position
			jsr plot 		// call Kernal subroutine to position cursor
			
			//  restore registers A, x and y from stack
			pla
			tay
			pla
			tax
			pla
			
			rts 			// return to caller
			
			// 
			//  end Subroutine "pwrap.sub"
			// 
			// 
			// required subroutine sources follow:
		
			.import source "newline.sub"	// prints a newline
			.import source "bt.sub"			// builds table of column zero addresses
			.import source "cls.sub"		// clear screen
			.import source "back_spc.sub"	// back-track in string to get previous space char

			// .import source "getlen.sub"		// get length of current non-space string segment

			// 
			//  ---- End of subroutine 'pwrap'
		
